package backendgo

import (
	"fmt"
	"strings"

	"github.com/andranikuz/aiwf/generator/core"
)

// ServiceGenerator генерирует service.go файл
type ServiceGenerator struct {
	ir *core.IR
}

// NewServiceGenerator создаёт новый генератор сервиса
func NewServiceGenerator(ir *core.IR) *ServiceGenerator {
	return &ServiceGenerator{ir: ir}
}

// Generate генерирует код сервиса
func (g *ServiceGenerator) Generate(packageName string) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString("// Code generated by aiwf. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Imports - only include fmt and aiwf
	// Note: strings is used in code generation but not in generated code
	b.WriteString("import (\n")
	b.WriteString("\t\"fmt\"\n")
	b.WriteString("\n")
	b.WriteString("\t\"github.com/andranikuz/aiwf/runtime/go/aiwf\"\n")
	b.WriteString(")\n\n")

	// Service struct
	b.WriteString("// Service provides access to all agents\n")
	b.WriteString("type Service struct {\n")
	b.WriteString("\tclient        aiwf.ModelClient\n")
	b.WriteString("\tthreadManager aiwf.ThreadManager\n")
	b.WriteString("\tartifactStore aiwf.ArtifactStore\n")
	b.WriteString("\tagents        *Agents\n")
	b.WriteString("}\n\n")

	// Constructor
	b.WriteString("// NewService creates a new service instance\n")
	b.WriteString("func NewService(client aiwf.ModelClient) *Service {\n")
	b.WriteString("\ts := &Service{\n")
	b.WriteString("\t\tclient: client,\n")
	b.WriteString("\t}\n\n")

	// Инициализируем агентов
	b.WriteString("\t// Initialize agents\n")
	if len(g.ir.Assistants) > 0 {
		// Генерируем переменные для агентов если их несколько
		hasMultipleAgents := len(g.ir.Assistants) > 1
		if hasMultipleAgents {
			for name := range g.ir.Assistants {
				agentTypeName := toPascalCase(name) + "Agent"
				b.WriteString(fmt.Sprintf("\t%s := New%s(client)\n",
					strings.ToLower(string(name[0])) + name[1:] + "Agent", agentTypeName))
				b.WriteString(fmt.Sprintf("\t%s.Types = s // Inject TypeProvider\n",
					strings.ToLower(string(name[0])) + name[1:] + "Agent"))
			}
			b.WriteString("\n")
		}
	}
	b.WriteString("\ts.agents = &Agents{\n")
	for name := range g.ir.Assistants {
		agentTypeName := toPascalCase(name) + "Agent"
		if len(g.ir.Assistants) > 1 {
			varName := strings.ToLower(string(name[0])) + name[1:] + "Agent"
			b.WriteString(fmt.Sprintf("\t\t%s: %s,\n", toPascalCase(name), varName))
		} else {
			b.WriteString(fmt.Sprintf("\t\t%s: New%s(client),\n", toPascalCase(name), agentTypeName))
		}
	}
	b.WriteString("\t}\n")

	// Inject TypeProvider for single agent
	if len(g.ir.Assistants) == 1 {
		for name := range g.ir.Assistants {
			b.WriteString(fmt.Sprintf("\ts.agents.%s.Types = s // Inject TypeProvider\n", toPascalCase(name)))
		}
	}
	b.WriteString("\n")

	b.WriteString("\treturn s\n")
	b.WriteString("}\n\n")

	// Builder methods
	b.WriteString("// WithThreadManager sets the thread manager\n")
	b.WriteString("func (s *Service) WithThreadManager(tm aiwf.ThreadManager) *Service {\n")
	b.WriteString("\ts.threadManager = tm\n")
	b.WriteString("\treturn s\n")
	b.WriteString("}\n\n")

	b.WriteString("// WithArtifactStore sets the artifact store\n")
	b.WriteString("func (s *Service) WithArtifactStore(store aiwf.ArtifactStore) *Service {\n")
	b.WriteString("\ts.artifactStore = store\n")
	b.WriteString("\treturn s\n")
	b.WriteString("}\n\n")

	// Getter for agents
	b.WriteString("// Agents returns the agents instance\n")
	b.WriteString("func (s *Service) Agents() *Agents {\n")
	b.WriteString("\treturn s.agents\n")
	b.WriteString("}\n\n")

	// TypeProvider implementation
	b.WriteString("// ============ TYPE PROVIDER IMPLEMENTATION ============\n\n")

	b.WriteString("// GetTypeMetadata returns metadata for a type\n")
	b.WriteString("func (s *Service) GetTypeMetadata(typeName string) (any, error) {\n")
	b.WriteString("\tif meta, ok := TypeMetadata[typeName]; ok {\n")
	b.WriteString("\t\treturn meta, nil\n")
	b.WriteString("\t}\n")
	b.WriteString("\treturn nil, fmt.Errorf(\"type %s not found\", typeName)\n")
	b.WriteString("}\n\n")

	b.WriteString("// GetInputTypeFor returns input type for an agent\n")
	b.WriteString("func (s *Service) GetInputTypeFor(agentName string) (string, any, error) {\n")
	b.WriteString("\tswitch agentName {\n")
	for name, assistant := range g.ir.Assistants {
		if assistant.InputTypeName != "" {
			b.WriteString(fmt.Sprintf("\tcase \"%s\":\n", name))
			b.WriteString(fmt.Sprintf("\t\treturn \"%s\", TypeMetadata[\"%s\"], nil\n",
				assistant.InputTypeName, assistant.InputTypeName))
		}
	}
	b.WriteString("\tdefault:\n")
	b.WriteString("\t\treturn \"\", nil, fmt.Errorf(\"agent %s not found\", agentName)\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	b.WriteString("// GetOutputTypeFor returns output type for an agent\n")
	b.WriteString("func (s *Service) GetOutputTypeFor(agentName string) (string, any, error) {\n")
	b.WriteString("\tswitch agentName {\n")
	for name, assistant := range g.ir.Assistants {
		if assistant.OutputTypeName != "" {
			b.WriteString(fmt.Sprintf("\tcase \"%s\":\n", name))
			b.WriteString(fmt.Sprintf("\t\treturn \"%s\", TypeMetadata[\"%s\"], nil\n",
				assistant.OutputTypeName, assistant.OutputTypeName))
		}
	}
	b.WriteString("\tdefault:\n")
	b.WriteString("\t\treturn \"\", nil, fmt.Errorf(\"agent %s not found\", agentName)\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	// Thread management helpers если есть треды
	if len(g.ir.Threads) > 0 {
		b.WriteString("// ============ THREAD MANAGEMENT ============\n\n")

		for threadName, thread := range g.ir.Threads {
			methodName := "Start" + toPascalCase(threadName) + "Thread"
			b.WriteString(fmt.Sprintf("// %s starts a new %s thread\n", methodName, threadName))
			b.WriteString(fmt.Sprintf("func (s *Service) %s() (*aiwf.ThreadState, error) {\n", methodName))
			b.WriteString("\tif s.threadManager == nil {\n")
			b.WriteString("\t\treturn nil, fmt.Errorf(\"thread manager not configured\")\n")
			b.WriteString("\t}\n")
			b.WriteString("\treturn s.threadManager.Start(nil, \"\", aiwf.ThreadBinding{\n")
			b.WriteString(fmt.Sprintf("\t\tName:     \"%s\",\n", threadName))
			b.WriteString(fmt.Sprintf("\t\tProvider: \"%s\",\n", thread.Provider))
			b.WriteString(fmt.Sprintf("\t\tStrategy: \"%s\",\n", thread.Strategy))
			b.WriteString("\t})\n")
			b.WriteString("}\n\n")
		}
	}

	return b.String(), nil
}

// needsEmailValidator проверяет, нужен ли валидатор email
func (g *ServiceGenerator) needsEmailValidator(td *core.TypeDef) bool {
	if td.Kind == core.KindString && td.Format == "email" {
		return true
	}
	if td.Kind == core.KindObject {
		for _, prop := range td.Properties {
			if g.needsEmailValidator(prop) {
				return true
			}
		}
	}
	if td.Kind == core.KindArray && td.Items != nil {
		return g.needsEmailValidator(td.Items)
	}
	return false
}