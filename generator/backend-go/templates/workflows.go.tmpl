package {{ .Package }}

import (
    "context"
    "fmt"

    "github.com/andranikuz/aiwf/runtime/go/aiwf"
)

type Workflows interface {
{{- range .Workflows }}
    {{ .MethodName }}() {{ .RunnerName }}
{{- end }}
}

type workflows struct {
    client aiwf.ModelClient
}

{{- range .Workflows }}
func (w *workflows) {{ .MethodName }}() {{ .RunnerName }} { return &{{ .StructName }}{client: w.client} }

type {{ .RunnerName }} interface {
    Run(ctx context.Context, input {{ .MethodName }}Input) ({{ .MethodName }}Output, *aiwf.Trace, error)
}

type {{ .StructName }} struct {
    client aiwf.ModelClient
}

func (r *{{ .StructName }}) Run(ctx context.Context, input {{ .MethodName }}Input) ({{ .MethodName }}Output, *aiwf.Trace, error) {
    agents := &agents{client: r.client}
    result := {{ .MethodName }}Output{}
    traces := make([]*aiwf.Trace, 0, {{ len .Steps }})
    prev := map[string]any{"input": input}

{{- $wf := . }}
{{- range $wf.Steps }}
    {{- if .Method }}
    {
        stepInput := {{ .InputType }}{}
        if candidate, ok := prev[{{ .InputSource }}].({{ .InputType }}); ok {
            stepInput = candidate
        }

        output, trace, err := agents.{{ .Method }}().Run(ctx, stepInput)
        if err != nil {
            return result, mergeTraces(traces...), fmt.Errorf("step {{ .Name }} failed: %w", err)
        }
        prev[{{ printf "%q" .Name }}] = output
        traces = append(traces, trace)
        {{- if .AssignToResult }}
        result = mergeWorkflowOutput(result, {{ $wf.MethodName }}Output(output))
        {{- end }}
    }
    {{- else }}
    // TODO: агент {{ .Assistant }} не сгенерирован автоматически, добавьте вызов вручную.
    {{- end }}
{{- end }}

    return result, mergeTraces(traces...), nil
}
{{- end }}
