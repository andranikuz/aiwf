package backendgo

import (
	"fmt"
	"strings"

	"github.com/andranikuz/aiwf/generator/core"
)

// ServerGenerator –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è –∞–≥–µ–Ω—Ç–æ–≤
type ServerGenerator struct {
	ir *core.IR
}

// NewServerGenerator —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞
func NewServerGenerator(ir *core.IR) *ServerGenerator {
	return &ServerGenerator{ir: ir}
}

// Generate –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–¥ HTTP —Å–µ—Ä–≤–µ—Ä–∞
func (g *ServerGenerator) Generate(packageName string) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString("// Code generated by aiwf. DO NOT EDIT.\n\n")
	b.WriteString("package main\n\n")

	// Imports
	b.WriteString("import (\n")
	b.WriteString("\t\"context\"\n")
	b.WriteString("\t\"encoding/json\"\n")
	b.WriteString("\t\"fmt\"\n")
	b.WriteString("\t\"log\"\n")
	b.WriteString("\t\"net/http\"\n")
	b.WriteString("\t\"os\"\n")
	b.WriteString("\t\"os/signal\"\n")
	b.WriteString("\t\"strings\"\n")
	b.WriteString("\t\"syscall\"\n")
	b.WriteString("\t\"time\"\n")
	b.WriteString("\n")
	// Import SDK from aiwf-server module
	b.WriteString(fmt.Sprintf("\t\"aiwf-server/%s\"\n", packageName))

	// Only import providers that are actually used
	usedProviders := make(map[string]bool)
	for _, assistant := range g.ir.Assistants {
		usedProviders[assistant.Use] = true
	}

	if usedProviders["openai"] {
		b.WriteString("\t\"github.com/andranikuz/aiwf/providers/openai\"\n")
	}
	if usedProviders["grok"] {
		b.WriteString("\t\"github.com/andranikuz/aiwf/providers/grok\"\n")
	}
	if usedProviders["anthropic"] {
		b.WriteString("\t\"github.com/andranikuz/aiwf/providers/anthropic\"\n")
	}

	b.WriteString("\t\"github.com/andranikuz/aiwf/runtime/go/aiwf\"\n")
	b.WriteString(")\n\n")

	// Server config struct
	b.WriteString(g.generateServerConfig())
	b.WriteString("\n")

	// Main function
	b.WriteString(g.generateMainFunction())
	b.WriteString("\n")

	// HTTP handlers
	b.WriteString(g.generateHandlers())
	b.WriteString("\n")

	// Helper functions
	b.WriteString(g.generateHelpers())

	return b.String(), nil
}

func (g *ServerGenerator) generateServerConfig() string {
	var b strings.Builder

	b.WriteString("// ServerConfig contains server configuration\n")
	b.WriteString("type ServerConfig struct {\n")
	b.WriteString("\tHost string\n")
	b.WriteString("\tPort int\n")
	b.WriteString("\tAPIKey string // Optional API key for authentication\n")
	b.WriteString("}\n\n")

	b.WriteString("// getConfig reads configuration from environment variables\n")
	b.WriteString("func getConfig() ServerConfig {\n")
	b.WriteString("\tport := 8080\n")
	b.WriteString("\tif p := os.Getenv(\"PORT\"); p != \"\" {\n")
	b.WriteString("\t\tfmt.Sscanf(p, \"%d\", &port)\n")
	b.WriteString("\t}\n\n")
	b.WriteString("\thost := os.Getenv(\"HOST\")\n")
	b.WriteString("\tif host == \"\" {\n")
	b.WriteString("\t\thost = \"127.0.0.1\"\n")
	b.WriteString("\t}\n\n")
	b.WriteString("\treturn ServerConfig{\n")
	b.WriteString("\t\tHost: host,\n")
	b.WriteString("\t\tPort: port,\n")
	b.WriteString("\t\tAPIKey: os.Getenv(\"API_KEY\"),\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n")

	return b.String()
}

func (g *ServerGenerator) generateMainFunction() string {
	var b strings.Builder

	b.WriteString("func main() {\n")
	b.WriteString("\tconfig := getConfig()\n\n")

	b.WriteString("\t// Initialize providers based on agent configuration\n")
	b.WriteString("\tproviders := initializeProviders()\n\n")

	b.WriteString("\t// Create service\n")
	b.WriteString("\tvar service *sdk.Service\n")
	b.WriteString("\tfor _, provider := range providers {\n")
	b.WriteString("\t\tif provider != nil {\n")
	b.WriteString("\t\t\tservice = sdk.NewService(provider)\n")
	b.WriteString("\t\t\tbreak\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t}\n\n")

	b.WriteString("\tif service == nil {\n")
	b.WriteString("\t\tlog.Fatal(\"No providers configured. Set OPENAI_API_KEY, GROK_API_KEY, or ANTHROPIC_API_KEY\")\n")
	b.WriteString("\t}\n\n")

	b.WriteString("\t// Setup HTTP server\n")
	b.WriteString("\tmux := http.NewServeMux()\n\n")

	b.WriteString("\t// Health check endpoint\n")
	b.WriteString("\tmux.HandleFunc(\"/health\", healthHandler)\n\n")

	b.WriteString("\t// List agents endpoint\n")
	b.WriteString("\tmux.HandleFunc(\"/agents\", listAgentsHandler)\n\n")

	// Generate routes for each agent
	b.WriteString("\t// Agent endpoints\n")
	for assistantName := range g.ir.Assistants {
		pascalName := toPascalCase(assistantName)
		b.WriteString(fmt.Sprintf("\tmux.HandleFunc(\"/agent/%s\", authMiddleware(config, handle%s(service)))\n", assistantName, pascalName))
	}

	b.WriteString("\n\t// Create server with timeouts\n")
	b.WriteString("\tsrv := &http.Server{\n")
	b.WriteString("\t\tAddr: fmt.Sprintf(\"%s:%d\", config.Host, config.Port),\n")
	b.WriteString("\t\tHandler: loggingMiddleware(mux),\n")
	b.WriteString("\t\tReadTimeout: 30 * time.Second,\n")
	b.WriteString("\t\tWriteTimeout: 30 * time.Second,\n")
	b.WriteString("\t\tIdleTimeout: 60 * time.Second,\n")
	b.WriteString("\t}\n\n")

	b.WriteString("\t// Graceful shutdown\n")
	b.WriteString("\tgo func() {\n")
	b.WriteString("\t\tsigChan := make(chan os.Signal, 1)\n")
	b.WriteString("\t\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n")
	b.WriteString("\t\t<-sigChan\n\n")
	b.WriteString("\t\tlog.Println(\"Shutting down server...\")\n")
	b.WriteString("\t\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n")
	b.WriteString("\t\tdefer cancel()\n\n")
	b.WriteString("\t\tif err := srv.Shutdown(ctx); err != nil {\n")
	b.WriteString("\t\t\tlog.Printf(\"Server shutdown error: %v\", err)\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t}()\n\n")

	b.WriteString("\tlog.Printf(\"üöÄ Server starting on http://%s:%d\", config.Host, config.Port)\n")
	b.WriteString("\tlog.Println(\"üì° Available endpoints:\")\n")
	b.WriteString("\tlog.Println(\"  GET  /health - Health check\")\n")
	b.WriteString("\tlog.Println(\"  GET  /agents - List all agents\")\n")

	for assistantName := range g.ir.Assistants {
		b.WriteString(fmt.Sprintf("\tlog.Println(\"  POST /agent/%s - %s agent\")\n", assistantName, toPascalCase(assistantName)))
	}

	b.WriteString("\n\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n")
	b.WriteString("\t\tlog.Fatalf(\"Server error: %v\", err)\n")
	b.WriteString("\t}\n")
	b.WriteString("\tlog.Println(\"Server stopped\")\n")
	b.WriteString("}\n")

	return b.String()
}

func (g *ServerGenerator) generateHandlers() string {
	var b strings.Builder

	b.WriteString("// ============ HANDLERS ============\n\n")

	// Health handler
	b.WriteString("func healthHandler(w http.ResponseWriter, r *http.Request) {\n")
	b.WriteString("\tif r.Method != http.MethodGet {\n")
	b.WriteString("\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n")
	b.WriteString("\t\treturn\n")
	b.WriteString("\t}\n")
	b.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
	b.WriteString("\tjson.NewEncoder(w).Encode(map[string]string{\"status\": \"ok\"})\n")
	b.WriteString("}\n\n")

	// List agents handler
	b.WriteString("func listAgentsHandler(w http.ResponseWriter, r *http.Request) {\n")
	b.WriteString("\tif r.Method != http.MethodGet {\n")
	b.WriteString("\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n")
	b.WriteString("\t\treturn\n")
	b.WriteString("\t}\n\n")
	b.WriteString("\tagents := []map[string]string{\n")
	for assistantName := range g.ir.Assistants {
		b.WriteString(fmt.Sprintf("\t\t{\"name\": \"%s\", \"endpoint\": \"/agent/%s\"},\n", assistantName, assistantName))
	}
	b.WriteString("\t}\n\n")
	b.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
	b.WriteString("\tjson.NewEncoder(w).Encode(map[string]interface{}{\"agents\": agents})\n")
	b.WriteString("}\n\n")

	// Generate handlers for each agent
	for assistantName, assistant := range g.ir.Assistants {
		pascalName := toPascalCase(assistantName)
		inputType := "interface{}"

		if assistant.InputType != nil {
			inputType = "sdk." + assistant.InputType.Name
		}

		b.WriteString(fmt.Sprintf("func handle%s(service *sdk.Service) http.HandlerFunc {\n", pascalName))
		b.WriteString("\treturn func(w http.ResponseWriter, r *http.Request) {\n")
		b.WriteString("\t\tif r.Method != http.MethodPost {\n")
		b.WriteString("\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n")
		b.WriteString("\t\t\treturn\n")
		b.WriteString("\t\t}\n\n")

		b.WriteString("\t\t// Parse request\n")
		b.WriteString(fmt.Sprintf("\t\tvar input %s\n", inputType))
		b.WriteString("\t\tif err := json.NewDecoder(r.Body).Decode(&input); err != nil {\n")
		b.WriteString("\t\t\trespondError(w, \"Invalid request body\", http.StatusBadRequest)\n")
		b.WriteString("\t\t\treturn\n")
		b.WriteString("\t\t}\n\n")

		b.WriteString("\t\t// Call agent\n")
		b.WriteString(fmt.Sprintf("\t\tresult, trace, err := service.Agents().%s.Run(r.Context(), input)\n", pascalName))
		b.WriteString("\t\tif err != nil {\n")
		b.WriteString("\t\t\trespondError(w, fmt.Sprintf(\"Agent error: %v\", err), http.StatusInternalServerError)\n")
		b.WriteString("\t\t\treturn\n")
		b.WriteString("\t\t}\n\n")

		b.WriteString("\t\t// Respond\n")
		b.WriteString("\t\trespondJSON(w, map[string]interface{}{\n")
		b.WriteString("\t\t\t\"data\": result,\n")
		b.WriteString("\t\t\t\"trace\": trace,\n")
		b.WriteString("\t\t})\n")
		b.WriteString("\t}\n")
		b.WriteString("}\n\n")
	}

	return b.String()
}

func (g *ServerGenerator) generateHelpers() string {
	var b strings.Builder

	b.WriteString("// ============ HELPERS ============\n\n")

	// Initialize providers
	b.WriteString("func initializeProviders() []aiwf.ModelClient {\n")
	b.WriteString("\tvar providers []aiwf.ModelClient\n\n")

	// Check which providers are used
	usedProviders := make(map[string]bool)
	for _, assistant := range g.ir.Assistants {
		usedProviders[assistant.Use] = true
	}

	if usedProviders["openai"] {
		b.WriteString("\t// OpenAI\n")
		b.WriteString("\tif apiKey := os.Getenv(\"OPENAI_API_KEY\"); apiKey != \"\" {\n")
		b.WriteString("\t\tif client, err := openai.NewClient(openai.ClientConfig{APIKey: apiKey}); err == nil {\n")
		b.WriteString("\t\t\tproviders = append(providers, client)\n")
		b.WriteString("\t\t\tlog.Println(\"‚úì OpenAI provider initialized\")\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n\n")
	}

	if usedProviders["grok"] {
		b.WriteString("\t// Grok\n")
		b.WriteString("\tif apiKey := os.Getenv(\"GROK_API_KEY\"); apiKey != \"\" {\n")
		b.WriteString("\t\tif client, err := grok.NewClient(grok.ClientConfig{APIKey: apiKey}); err == nil {\n")
		b.WriteString("\t\t\tproviders = append(providers, client)\n")
		b.WriteString("\t\t\tlog.Println(\"‚úì Grok provider initialized\")\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n\n")
	}

	if usedProviders["anthropic"] {
		b.WriteString("\t// Anthropic\n")
		b.WriteString("\tif apiKey := os.Getenv(\"ANTHROPIC_API_KEY\"); apiKey != \"\" {\n")
		b.WriteString("\t\tif client, err := anthropic.NewClient(anthropic.ClientConfig{APIKey: apiKey}); err == nil {\n")
		b.WriteString("\t\t\tproviders = append(providers, client)\n")
		b.WriteString("\t\t\tlog.Println(\"‚úì Anthropic provider initialized\")\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n\n")
	}

	b.WriteString("\treturn providers\n")
	b.WriteString("}\n\n")

	// Middleware functions
	b.WriteString("// authMiddleware checks API key if configured\n")
	b.WriteString("func authMiddleware(config ServerConfig, next http.HandlerFunc) http.HandlerFunc {\n")
	b.WriteString("\treturn func(w http.ResponseWriter, r *http.Request) {\n")
	b.WriteString("\t\tif config.APIKey != \"\" {\n")
	b.WriteString("\t\t\tapiKey := r.Header.Get(\"X-API-Key\")\n")
	b.WriteString("\t\t\tif apiKey == \"\" {\n")
	b.WriteString("\t\t\t\tapiKey = r.Header.Get(\"Authorization\")\n")
	b.WriteString("\t\t\t\tapiKey = strings.TrimPrefix(apiKey, \"Bearer \")\n")
	b.WriteString("\t\t\t}\n")
	b.WriteString("\t\t\tif apiKey != config.APIKey {\n")
	b.WriteString("\t\t\t\trespondError(w, \"Unauthorized\", http.StatusUnauthorized)\n")
	b.WriteString("\t\t\t\treturn\n")
	b.WriteString("\t\t\t}\n")
	b.WriteString("\t\t}\n")
	b.WriteString("\t\tnext(w, r)\n")
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	b.WriteString("// loggingMiddleware logs HTTP requests\n")
	b.WriteString("func loggingMiddleware(next http.Handler) http.Handler {\n")
	b.WriteString("\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n")
	b.WriteString("\t\tstart := time.Now()\n")
	b.WriteString("\t\tnext.ServeHTTP(w, r)\n")
	b.WriteString("\t\tlog.Printf(\"%s %s - %v\", r.Method, r.URL.Path, time.Since(start))\n")
	b.WriteString("\t})\n")
	b.WriteString("}\n\n")

	// Response helpers
	b.WriteString("func respondJSON(w http.ResponseWriter, data interface{}) {\n")
	b.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
	b.WriteString("\tw.WriteHeader(http.StatusOK)\n")
	b.WriteString("\tjson.NewEncoder(w).Encode(data)\n")
	b.WriteString("}\n\n")

	b.WriteString("func respondError(w http.ResponseWriter, message string, status int) {\n")
	b.WriteString("\tw.Header().Set(\"Content-Type\", \"application/json\")\n")
	b.WriteString("\tw.WriteHeader(status)\n")
	b.WriteString("\tjson.NewEncoder(w).Encode(map[string]string{\"error\": message})\n")
	b.WriteString("}\n")

	return b.String()
}
