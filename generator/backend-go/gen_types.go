package backendgo

import (
	"fmt"
	"strings"

	"github.com/andranikuz/aiwf/generator/core"
)

// TypesGenerator генерирует types.go файл
type TypesGenerator struct {
	ir      *core.IR
	imports map[string]bool
}

// NewTypesGenerator создаёт новый генератор типов
func NewTypesGenerator(ir *core.IR) *TypesGenerator {
	return &TypesGenerator{
		ir:      ir,
		imports: make(map[string]bool),
	}
}

// Generate генерирует код типов
func (g *TypesGenerator) Generate(packageName string) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString(fmt.Sprintf("// Code generated by aiwf. DO NOT EDIT.\n\n"))
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Собираем импорты
	g.collectImports()
	g.removeUnusedImports()

	// Добавляем импорт strings если нужна email валидация
	if g.hasEmailValidation() {
		g.imports[`"strings"`] = true
		g.imports[`"fmt"`] = true
	}

	// Импорты
	if len(g.imports) > 0 {
		b.WriteString("import (\n")
		for imp := range g.imports {
			b.WriteString(fmt.Sprintf("\t%s\n", imp))
		}
		b.WriteString(")\n\n")
	}

	// Генерируем типы
	if g.ir.Types != nil {
		for typeName, typeDef := range g.ir.Types.Types {
			typeCode, err := g.generateType(typeName, typeDef)
			if err != nil {
				return "", fmt.Errorf("failed to generate type %s: %w", typeName, err)
			}
			b.WriteString(typeCode)
			b.WriteString("\n")
		}
	}

	// Генерируем валидаторы
	b.WriteString("// ============ VALIDATORS ============\n\n")
	if g.ir.Types != nil {
		for typeName, typeDef := range g.ir.Types.Types {
			if typeDef.Kind == core.KindObject {
				validator := g.generateValidator(typeName, typeDef)
				b.WriteString(validator)
				b.WriteString("\n")
			}
		}
	}

	// Генерируем метаданные типов для провайдеров
	b.WriteString("// ============ TYPE METADATA ============\n\n")
	b.WriteString(g.generateTypeMetadata())

	// Add helper functions if needed
	b.WriteString("// ============ HELPERS ============\n\n")
	if g.hasEmailValidation() {
		b.WriteString("func isValidEmail(email string) bool {\n")
		b.WriteString("\t// Simple email validation\n")
		b.WriteString("\treturn strings.Contains(email, \"@\") && strings.Contains(email, \".\")\n")
		b.WriteString("}\n")
		g.imports[`"strings"`] = true
	}

	return b.String(), nil
}

// collectImports собирает необходимые импорты
func (g *TypesGenerator) collectImports() {
	if g.ir.Types == nil {
		return
	}

	for _, typeDef := range g.ir.Types.Types {
		g.collectImportsFromType(typeDef)
	}
}

// collectImportsFromType собирает импорты из типа
func (g *TypesGenerator) collectImportsFromType(td *core.TypeDef) {
	switch td.Kind {
	case core.KindDatetime, core.KindDate:
		g.imports[`"time"`] = true
	case core.KindUUID:
		// Можно добавить uuid пакет если нужно
	case core.KindObject:
		for _, prop := range td.Properties {
			g.collectImportsFromType(prop)
		}
	case core.KindArray:
		if td.Items != nil {
			g.collectImportsFromType(td.Items)
		}
	}

	// Для валидации
	if td.MinLength != nil || td.MaxLength != nil {
		g.imports[`"fmt"`] = true
	}
}

// removeUnusedImports removes imports that are not actually used
func (g *TypesGenerator) removeUnusedImports() {
	if g.ir.Types == nil {
		return
	}

	// Check if time is actually used
	timeUsed := false
	for _, typeDef := range g.ir.Types.Types {
		if g.usesTimeInStruct(typeDef) {
			timeUsed = true
			break
		}
	}
	if !timeUsed {
		delete(g.imports, `"time"`)
	}

	// Check if fmt is actually used
	fmtUsed := false
	for _, typeDef := range g.ir.Types.Types {
		if g.usesFmt(typeDef) {
			fmtUsed = true
			break
		}
	}
	if !fmtUsed {
		delete(g.imports, `"fmt"`)
	}
}

// usesTimeInStruct checks if a type uses time in its struct definition
func (g *TypesGenerator) usesTimeInStruct(td *core.TypeDef) bool {
	// Only check if it's an Object type (which generates a struct)
	if td.Kind != core.KindObject {
		return false
	}

	// Check if any property is datetime or date
	for _, prop := range td.Properties {
		if prop.Kind == core.KindDatetime || prop.Kind == core.KindDate {
			return true
		}
		// Recursively check nested objects
		if prop.Kind == core.KindArray && prop.Items != nil {
			if prop.Items.Kind == core.KindDatetime || prop.Items.Kind == core.KindDate {
				return true
			}
		}
	}

	return false
}

// usesRegexp checks if a type needs regexp
func (g *TypesGenerator) usesRegexp(td *core.TypeDef) bool {
	// Regexp is only needed if we're generating validators with email or url format
	// Since we're only generating validators for objects, check them
	if td.Kind != core.KindObject {
		return false
	}

	for _, prop := range td.Properties {
		if prop.Format == "email" || prop.Format == "url" {
			return true
		}
	}

	return false
}

// usesFmt checks if a type needs fmt
func (g *TypesGenerator) usesFmt(td *core.TypeDef) bool {
	// fmt is needed if we're generating validators with:
	// - length constraints
	// - email/url validation
	if td.Kind != core.KindObject {
		return false
	}

	for _, prop := range td.Properties {
		if prop.MinLength != nil || prop.MaxLength != nil {
			return true
		}
		// Check for email or url validation
		if prop.Format == "email" || prop.Format == "url" {
			return true
		}
	}

	return false
}

// hasEmailValidation checks if any type needs email validation
func (g *TypesGenerator) hasEmailValidation() bool {
	if g.ir.Types == nil {
		return false
	}

	for _, typeDef := range g.ir.Types.Types {
		if typeDef.Kind == core.KindObject {
			for _, prop := range typeDef.Properties {
				if prop.Format == "email" {
					return true
				}
			}
		}
	}

	return false
}

// generateType генерирует Go структуру из TypeDef
func (g *TypesGenerator) generateType(name string, td *core.TypeDef) (string, error) {
	var b strings.Builder

	switch td.Kind {
	case core.KindEnum:
		// Генерируем тип и константы для enum
		b.WriteString(fmt.Sprintf("type %s string\n\n", name))
		b.WriteString("const (\n")
		for _, value := range td.Enum {
			constName := fmt.Sprintf("%s%s", name, toPascalCase(value))
			b.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, name, value))
		}
		b.WriteString(")\n")

	case core.KindObject:
		// Генерируем структуру
		b.WriteString(fmt.Sprintf("// %s represents %s\n", name, name))
		b.WriteString(fmt.Sprintf("type %s struct {\n", name))

		for fieldName, fieldType := range td.Properties {
			goFieldName := toPascalCase(fieldName)
			goType, err := g.goType(fieldType)
			if err != nil {
				return "", err
			}
			jsonTag := fmt.Sprintf("`json:\"%s\"`", fieldName)
			b.WriteString(fmt.Sprintf("\t%s %s %s\n", goFieldName, goType, jsonTag))
		}
		b.WriteString("}\n")

	default:
		// Для простых типов создаём type alias
		goType, err := g.goType(td)
		if err != nil {
			return "", err
		}
		b.WriteString(fmt.Sprintf("type %s %s\n", name, goType))
	}

	return b.String(), nil
}

// goType конвертирует TypeDef в Go тип
func (g *TypesGenerator) goType(td *core.TypeDef) (string, error) {
	switch td.Kind {
	case core.KindString:
		return "string", nil
	case core.KindInt:
		return "int", nil
	case core.KindNumber:
		return "float64", nil
	case core.KindBool:
		return "bool", nil
	case core.KindDatetime, core.KindDate:
		return "time.Time", nil
	case core.KindUUID:
		return "string", nil // или uuid.UUID если используем пакет
	case core.KindAny:
		return "interface{}", nil
	case core.KindArray:
		if td.Items == nil {
			return "", fmt.Errorf("array without items")
		}
		itemType, err := g.goType(td.Items)
		if err != nil {
			return "", err
		}
		return "[]" + itemType, nil
	case core.KindMap:
		if td.ValueType == nil {
			return "", fmt.Errorf("map without value type")
		}
		valueType, err := g.goType(td.ValueType)
		if err != nil {
			return "", err
		}
		return "map[string]" + valueType, nil
	case core.KindRef:
		// Убираем $ из ссылки
		refName := strings.TrimPrefix(td.Ref, "$")
		// Обрабатываем namespace (module.Type)
		if idx := strings.LastIndex(refName, "."); idx > 0 {
			refName = refName[idx+1:]
		}
		// Проверяем, есть ли такой тип
		if g.ir.Types != nil {
			if refType, ok := g.ir.Types.Types[refName]; ok {
				// Для объектов возвращаем указатель
				if refType.Kind == core.KindObject {
					return "*" + refName, nil
				}
				return refName, nil
			}
		}
		return refName, nil
	case core.KindEnum:
		// Для inline enum возвращаем string
		return "string", nil
	case core.KindObject:
		// Для inline объектов нужно генерировать отдельный тип
		// Пока возвращаем map
		return "map[string]interface{}", nil
	default:
		return "", fmt.Errorf("unknown type kind: %s", td.Kind)
	}
}

// generateValidator генерирует функцию валидации
func (g *TypesGenerator) generateValidator(name string, td *core.TypeDef) string {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("// Validate%s validates %s\n", name, name))
	b.WriteString(fmt.Sprintf("func Validate%s(v *%s) error {\n", name, name))

	hasValidation := false
	for fieldName, fieldType := range td.Properties {
		validation := g.generateFieldValidation(fieldName, fieldType)
		if validation != "" {
			b.WriteString(validation)
			hasValidation = true
		}
	}

	if !hasValidation {
		b.WriteString("\t// No validation rules\n")
	}

	b.WriteString("\treturn nil\n")
	b.WriteString("}\n")

	return b.String()
}

// generateFieldValidation генерирует валидацию для поля
func (g *TypesGenerator) generateFieldValidation(fieldName string, td *core.TypeDef) string {
	var validations []string
	goFieldName := toPascalCase(fieldName)

	switch td.Kind {
	case core.KindString:
		if td.MinLength != nil && td.MaxLength != nil {
			validations = append(validations, fmt.Sprintf(
				"\tif len(v.%s) < %d || len(v.%s) > %d {\n\t\treturn fmt.Errorf(\"%s length must be between %d and %d, got %%d\", len(v.%s))\n\t}\n",
				goFieldName, *td.MinLength, goFieldName, *td.MaxLength,
				fieldName, *td.MinLength, *td.MaxLength, goFieldName,
			))
		} else if td.MinLength != nil {
			validations = append(validations, fmt.Sprintf(
				"\tif len(v.%s) < %d {\n\t\treturn fmt.Errorf(\"%s length must be at least %d, got %%d\", len(v.%s))\n\t}\n",
				goFieldName, *td.MinLength, fieldName, *td.MinLength, goFieldName,
			))
		} else if td.MaxLength != nil {
			validations = append(validations, fmt.Sprintf(
				"\tif len(v.%s) > %d {\n\t\treturn fmt.Errorf(\"%s length must be at most %d, got %%d\", len(v.%s))\n\t}\n",
				goFieldName, *td.MaxLength, fieldName, *td.MaxLength, goFieldName,
			))
		}

		if td.Format == "email" {
			validations = append(validations, fmt.Sprintf(
				"\tif !isValidEmail(v.%s) {\n\t\treturn fmt.Errorf(\"%s must be a valid email\")\n\t}\n",
				goFieldName, fieldName,
			))
		}

	case core.KindInt, core.KindNumber:
		if td.Min != nil && td.Max != nil {
			validations = append(validations, fmt.Sprintf(
				"\tif v.%s < %v || v.%s > %v {\n\t\treturn fmt.Errorf(\"%s must be between %v and %v, got %%v\", v.%s)\n\t}\n",
				goFieldName, *td.Min, goFieldName, *td.Max,
				fieldName, *td.Min, *td.Max, goFieldName,
			))
		}

	case core.KindArray:
		if td.MinItems != nil && td.MaxItems != nil {
			validations = append(validations, fmt.Sprintf(
				"\tif len(v.%s) < %d || len(v.%s) > %d {\n\t\treturn fmt.Errorf(\"%s must have between %d and %d items, got %%d\", len(v.%s))\n\t}\n",
				goFieldName, *td.MinItems, goFieldName, *td.MaxItems,
				fieldName, *td.MinItems, *td.MaxItems, goFieldName,
			))
		}
	}

	return strings.Join(validations, "")
}

// generateTypeMetadata генерирует метаданные типов
func (g *TypesGenerator) generateTypeMetadata() string {
	var b strings.Builder

	b.WriteString("// TypeMetadata exports type definitions for providers\n")
	b.WriteString("var TypeMetadata = map[string]interface{}{\n")

	if g.ir.Types != nil {
		for typeName, typeDef := range g.ir.Types.Types {
			schema := g.typeDefToSchema(typeName, typeDef)
			b.WriteString(fmt.Sprintf("\t\"%s\": %s,\n", typeName, schema))
		}
	}

	b.WriteString("}\n")

	return b.String()
}

// typeDefToSchema конвертирует TypeDef в JSON Schema representation для TypeMetadata
func (g *TypesGenerator) typeDefToSchema(typeName string, td *core.TypeDef) string {
	var b strings.Builder
	b.WriteString("map[string]interface{}{\n")

	switch td.Kind {
	case core.KindString:
		b.WriteString("\t\t\"type\": \"string\",\n")
	case core.KindInt:
		b.WriteString("\t\t\"type\": \"integer\",\n")
	case core.KindNumber:
		b.WriteString("\t\t\"type\": \"number\",\n")
	case core.KindBool:
		b.WriteString("\t\t\"type\": \"boolean\",\n")
	case core.KindDatetime:
		b.WriteString("\t\t\"type\": \"string\",\n")
		b.WriteString("\t\t\"format\": \"date-time\",\n")
	case core.KindDate:
		b.WriteString("\t\t\"type\": \"string\",\n")
		b.WriteString("\t\t\"format\": \"date\",\n")
	case core.KindUUID:
		b.WriteString("\t\t\"type\": \"string\",\n")
		b.WriteString("\t\t\"format\": \"uuid\",\n")
	case core.KindEnum:
		b.WriteString("\t\t\"type\": \"string\",\n")
		b.WriteString("\t\t\"enum\": []string{")
		for i, e := range td.Enum {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(fmt.Sprintf("\"%s\"", e))
		}
		b.WriteString("},\n")
	case core.KindArray:
		b.WriteString("\t\t\"type\": \"array\",\n")
		if td.Items != nil {
			b.WriteString("\t\t\"items\": ")
			b.WriteString(g.typeDefToSchema("", td.Items))
			b.WriteString(",\n")
		}
	case core.KindObject:
		b.WriteString("\t\t\"type\": \"object\",\n")
		if len(td.Properties) > 0 {
			b.WriteString("\t\t\"properties\": map[string]interface{}{\n")
			required := []string{}
			for propName, propDef := range td.Properties {
				b.WriteString(fmt.Sprintf("\t\t\t\"%s\": %s,\n", propName, g.typeDefToSchema("", propDef)))
				required = append(required, propName)
			}
			b.WriteString("\t\t},\n")
			b.WriteString("\t\t\"required\": []string{")
			for i, r := range required {
				if i > 0 {
					b.WriteString(", ")
				}
				b.WriteString(fmt.Sprintf("\"%s\"", r))
			}
			b.WriteString("},\n")
		}
		b.WriteString("\t\t\"additionalProperties\": false,\n")
	case core.KindMap:
		b.WriteString("\t\t\"type\": \"object\",\n")
		b.WriteString("\t\t\"additionalProperties\": true,\n")
	case core.KindRef:
		// Resolve reference
		refName := strings.TrimPrefix(td.Ref, "$")
		if idx := strings.LastIndex(refName, "."); idx > 0 {
			refName = refName[idx+1:]
		}
		// Look up the referenced type
		if g.ir.Types != nil {
			if refType, ok := g.ir.Types.Types[refName]; ok {
				// Recursively generate schema for referenced type
				return g.typeDefToSchema(refName, refType)
			}
		}
		// Fallback if reference not found
		b.WriteString("\t\t\"type\": \"object\",\n")
	default:
		b.WriteString("\t\t\"type\": \"object\",\n")
	}

	b.WriteString("\t}")
	return b.String()
}

