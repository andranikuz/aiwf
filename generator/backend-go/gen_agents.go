package backendgo

import (
	"fmt"
	"strings"

	"github.com/andranikuz/aiwf/generator/core"
)

// AgentsGenerator генерирует agents.go файл
type AgentsGenerator struct {
	ir *core.IR
}

// NewAgentsGenerator создаёт новый генератор агентов
func NewAgentsGenerator(ir *core.IR) *AgentsGenerator {
	return &AgentsGenerator{ir: ir}
}

// Generate генерирует код агентов
func (g *AgentsGenerator) Generate(packageName string) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString("// Code generated by aiwf. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Проверяем, нужен ли json импорт
	needsJSON := false
	for _, assistant := range g.ir.Assistants {
		if assistant.OutputTypeName != "string" {
			needsJSON = true
			break
		}
	}

	// Imports
	b.WriteString("import (\n")
	b.WriteString("\t\"context\"\n")
	if needsJSON {
		b.WriteString("\t\"encoding/json\"\n")
	}
	b.WriteString("\t\"fmt\"\n")
	b.WriteString("\n")
	b.WriteString("\t\"github.com/andranikuz/aiwf/runtime/go/aiwf\"\n")
	b.WriteString(")\n\n")

	// Генерируем структуру Agents
	b.WriteString("// Agents contains all generated agents\n")
	b.WriteString("type Agents struct {\n")
	for name := range g.ir.Assistants {
		agentTypeName := toPascalCase(name) + "Agent"
		b.WriteString(fmt.Sprintf("\t%s *%s\n", toPascalCase(name), agentTypeName))
	}
	b.WriteString("}\n\n")

	// Генерируем каждого агента
	for name, assistant := range g.ir.Assistants {
		agentCode, err := g.generateAgent(name, assistant)
		if err != nil {
			return "", fmt.Errorf("failed to generate agent %s: %w", name, err)
		}
		b.WriteString(agentCode)
		b.WriteString("\n")
	}

	return b.String(), nil
}

// generateAgent генерирует код для одного агента
func (g *AgentsGenerator) generateAgent(name string, assistant core.IRAssistant) (string, error) {
	var b strings.Builder

	agentTypeName := toPascalCase(name) + "Agent"
	inputTypeName := assistant.InputTypeName
	outputTypeName := assistant.OutputTypeName

	// Если типы не указаны, используем interface{}
	if inputTypeName == "" {
		inputTypeName = "map[string]interface{}"
	} else {
		inputTypeName = toPascalCase(inputTypeName)
	}
	if outputTypeName == "" {
		outputTypeName = "map[string]interface{}"
	} else if outputTypeName == "string" {
		// Для базового типа string не преобразуем в PascalCase
		outputTypeName = "string"
	} else {
		outputTypeName = toPascalCase(outputTypeName)
	}

	// Структура агента
	b.WriteString(fmt.Sprintf("// %s represents the %s agent\n", agentTypeName, name))
	b.WriteString(fmt.Sprintf("type %s struct {\n", agentTypeName))
	b.WriteString("\taiwf.AgentBase\n")
	if assistant.Thread != nil {
		b.WriteString("\tthreadBinding *aiwf.ThreadBinding\n")
	}
	b.WriteString("}\n\n")

	// Конструктор
	b.WriteString(fmt.Sprintf("// New%s creates a new %s agent\n", agentTypeName, name))
	b.WriteString(fmt.Sprintf("func New%s(client aiwf.ModelClient) *%s {\n", agentTypeName, agentTypeName))
	b.WriteString(fmt.Sprintf("\treturn &%s{\n", agentTypeName))
	b.WriteString("\t\tAgentBase: aiwf.AgentBase{\n")
	b.WriteString("\t\t\tConfig: aiwf.AgentConfig{\n")
	b.WriteString(fmt.Sprintf("\t\t\t\tName:           \"%s\",\n", name))
	b.WriteString(fmt.Sprintf("\t\t\t\tModel:          \"%s\",\n", assistant.Model))

	// Экранируем системный промпт
	escapedPrompt := strings.ReplaceAll(assistant.SystemPrompt, "`", "` + \"`\" + `")
	escapedPrompt = strings.ReplaceAll(escapedPrompt, "\n", "\\n")
	b.WriteString(fmt.Sprintf("\t\t\t\tSystemPrompt:   `%s`,\n", escapedPrompt))

	b.WriteString(fmt.Sprintf("\t\t\t\tInputTypeName:  \"%s\",\n", assistant.InputTypeName))
	b.WriteString(fmt.Sprintf("\t\t\t\tOutputTypeName: \"%s\",\n", assistant.OutputTypeName))
	b.WriteString("\t\t\t\tMaxTokens:      2000,\n")
	b.WriteString("\t\t\t\tTemperature:    0.7,\n")
	b.WriteString("\t\t\t},\n")
	b.WriteString("\t\t\tClient: client,\n")
	b.WriteString("\t\t},\n")
	if assistant.Thread != nil {
		b.WriteString(fmt.Sprintf("\t\tthreadBinding: &aiwf.ThreadBinding{\n"))
		b.WriteString(fmt.Sprintf("\t\t\tName:     \"%s\",\n", assistant.Thread.Use))
		b.WriteString(fmt.Sprintf("\t\t\tStrategy: \"%s\",\n", assistant.Thread.Strategy))
		b.WriteString("\t\t},\n")
	}
	b.WriteString("\t}\n")
	b.WriteString("}\n\n")

	// Метод Run
	b.WriteString(fmt.Sprintf("// Run executes the %s agent\n", name))
	b.WriteString(fmt.Sprintf("func (a *%s) Run(ctx context.Context, input %s) (*%s, *aiwf.Trace, error) {\n",
		agentTypeName, inputTypeName, outputTypeName))

	// Валидация если есть
	if assistant.InputTypeName != "" {
		b.WriteString(fmt.Sprintf("\t// Validate input\n"))
		b.WriteString(fmt.Sprintf("\tif err := Validate%s(&input); err != nil {\n", inputTypeName))
		b.WriteString("\t\treturn nil, nil, fmt.Errorf(\"validation failed: %w\", err)\n")
		b.WriteString("\t}\n\n")
	}

	// Вызов модели
	b.WriteString("\t// Call model\n")
	b.WriteString("\tresult, trace, err := a.CallModel(ctx, input, nil)\n")
	b.WriteString("\tif err != nil {\n")
	b.WriteString("\t\treturn nil, trace, err\n")
	b.WriteString("\t}\n\n")

	// Парсинг результата
	b.WriteString("\t// Parse response\n")
	if assistant.OutputTypeName == "string" {
		// Если тип вывода string, просто конвертируем байты в строку
		b.WriteString("\toutput := string(result)\n")
		b.WriteString("\treturn &output, trace, nil\n")
	} else {
		// Иначе парсим как JSON
		b.WriteString(fmt.Sprintf("\tvar output %s\n", outputTypeName))
		b.WriteString("\tif err := json.Unmarshal(result, &output); err != nil {\n")
		b.WriteString("\t\treturn nil, trace, fmt.Errorf(\"failed to parse response: %w\", err)\n")
		b.WriteString("\t}\n\n")
		b.WriteString("\treturn &output, trace, nil\n")
	}
	b.WriteString("}\n\n")

	// Метод RunWithThread если агент поддерживает треды
	if assistant.Thread != nil {
		b.WriteString(fmt.Sprintf("// RunWithThread executes the %s agent with thread state\n", name))
		b.WriteString(fmt.Sprintf("func (a *%s) RunWithThread(ctx context.Context, input %s, thread *aiwf.ThreadState) (*%s, *aiwf.Trace, error) {\n",
			agentTypeName, inputTypeName, outputTypeName))

		if assistant.InputTypeName != "" {
			b.WriteString(fmt.Sprintf("\tif err := Validate%s(&input); err != nil {\n", inputTypeName))
			b.WriteString("\t\treturn nil, nil, fmt.Errorf(\"validation failed: %w\", err)\n")
			b.WriteString("\t}\n\n")
		}

		b.WriteString("\tresult, trace, err := a.CallModel(ctx, input, thread)\n")
		b.WriteString("\tif err != nil {\n")
		b.WriteString("\t\treturn nil, trace, err\n")
		b.WriteString("\t}\n\n")

		if assistant.OutputTypeName == "string" {
			// Если тип вывода string, просто конвертируем байты в строку
			b.WriteString("\toutput := string(result)\n")
			b.WriteString("\treturn &output, trace, nil\n")
		} else {
			// Иначе парсим как JSON
			b.WriteString(fmt.Sprintf("\tvar output %s\n", outputTypeName))
			b.WriteString("\tif err := json.Unmarshal(result, &output); err != nil {\n")
			b.WriteString("\t\treturn nil, trace, fmt.Errorf(\"failed to parse response: %w\", err)\n")
			b.WriteString("\t}\n\n")
			b.WriteString("\treturn &output, trace, nil\n")
		}
		b.WriteString("}\n\n")

		// Метод для получения thread binding
		b.WriteString(fmt.Sprintf("// ThreadBinding returns thread configuration for %s\n", name))
		b.WriteString(fmt.Sprintf("func (a *%s) ThreadBinding() *aiwf.ThreadBinding {\n", agentTypeName))
		b.WriteString("\treturn a.threadBinding\n")
		b.WriteString("}\n\n")
	}

	// Если у агента есть диалоговый режим
	if assistant.Dialog != nil {
		b.WriteString(fmt.Sprintf("// RunDialog executes the %s agent in dialog mode\n", name))
		b.WriteString(fmt.Sprintf("func (a *%s) RunDialog(ctx context.Context, input %s, thread *aiwf.ThreadState, maxRounds int) (*%s, *aiwf.Trace, error) {\n",
			agentTypeName, inputTypeName, outputTypeName))
		b.WriteString("\t// TODO: Implement dialog logic\n")
		b.WriteString("\treturn a.RunWithThread(ctx, input, thread)\n")
		b.WriteString("}\n\n")
	}

	return b.String(), nil
}